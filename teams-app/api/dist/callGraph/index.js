"use strict";
/* This code sample provides a starter kit to implement server side logic for your Teams App in TypeScript,
 * refer to https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference for complete Azure Functions
 * developer guide.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// Import polyfills for fetch required by msgraph-sdk-javascript.
require("isomorphic-fetch");
const teamsfx_1 = require("@microsoft/teamsfx");
const config_1 = require("../config");
// Define an enum called FilesType with four possible values for different types of Microsoft Office files.
var FilesType;
(function (FilesType) {
    FilesType["WORD"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    FilesType["EXCEL"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    FilesType["PPT"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
    FilesType["VISIO"] = "application/vnd.ms-visio.drawing";
})(FilesType || (FilesType = {}));
/**
 * This function handles requests from teamsfx client.
 * The HTTP request should contain an SSO token queried from Teams in the header.
 * Before trigger this function, teamsfx binding would process the SSO token and generate teamsfx configuration.
 *
 * This function initializes the teamsfx SDK with the configuration and calls these APIs:
 * - new OnBehalfOfUserCredential(accessToken, oboAuthConfig) - Construct OnBehalfOfUserCredential instance with the received SSO token and initialized configuration.
 * - getUserInfo() - Get the user's information from the received SSO token.
 * - createMicrosoftGraphClientWithCredential() - Get a graph client to access user's Microsoft 365 data.
 *
 * The response contains multiple message blocks constructed into a JSON object, including:
 * - An echo of the request body.
 * - The display name encoded in the SSO token.
 * - Current user's Microsoft 365 profile if the user has consented.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 */
/**
 * This function is the entry point for the Azure Function.
 * It handles HTTP requests from the Teams client and calls the appropriate function based on the request parameters.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 * @returns {Promise<Response>} - A promise that resolves with the HTTP response.
 */
function run(context, req, teamsfxContext) {
    return __awaiter(this, void 0, void 0, function* () {
        context.log("HTTP trigger function processed a request.");
        // Initialize response.
        const res = {
            status: 200,
            body: {},
        };
        // Put an echo into response body.
        res.body.receivedHTTPRequestBody = req.body || "";
        // Prepare access token.
        const accessToken = teamsfxContext["AccessToken"];
        if (!accessToken) {
            return {
                status: 400,
                body: {
                    error: "No access token was found in request header.",
                },
            };
        }
        // Set up the configuration for the OnBehalfOfUserCredential.
        const oboAuthConfig = {
            authorityHost: config_1.default.authorityHost,
            clientId: config_1.default.clientId,
            tenantId: config_1.default.tenantId,
            clientSecret: config_1.default.clientSecret,
        };
        let oboCredential;
        try {
            // Construct the OnBehalfOfUserCredential using the access token and configuration.
            oboCredential = new teamsfx_1.OnBehalfOfUserCredential(accessToken, oboAuthConfig);
        }
        catch (e) {
            context.log.error(e);
            return {
                status: 500,
                body: {
                    error: "Failed to construct OnBehalfOfUserCredential using your accessToken. " +
                        "Ensure your function app is configured with the right Azure AD App registration.",
                },
            };
        }
        // Get the graphType, method, and request data from the HTTP request.
        const graphType = req.query["graphType"];
        const method = req.method;
        const reqData = req.body;
        try {
            // Call the appropriate function based on the graphType and method.
            const result = yield handleRequest(oboCredential, graphType, method, reqData);
            res.body = Object.assign(Object.assign({}, res.body), result);
        }
        catch (e) {
            context.log.error(e);
            return {
                status: 500,
                body: {
                    error: "Failed to process request.",
                },
            };
        }
        return res;
    });
}
exports.default = run;
/**
 * Handles the request based on the given graphType and method.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @param {string} graphType - The type of graph to query (e.g. "calendar", "task").
 * @param {string} method - The HTTP method to use (e.g. "GET", "POST").
 * @param {any} reqData - The request data to use (if applicable).
 * @returns {Promise<any>} - A promise that resolves with the result of the request.
 */
function handleRequest(oboCredential, graphType, method, reqData) {
    return __awaiter(this, void 0, void 0, function* () {
        // Switch statement to handle different graphType and method combinations
        switch (`${graphType}:${method}`) {
            // If graphType is "calendar" and method is "GET"
            case "calendar:GET": {
                // Call getCalendarEvents function to get calendar events
                const events = yield getCalendarEvents(oboCredential);
                return { eventResult: events };
            }
            // If graphType is "task" and method is "GET"
            case "task:GET": {
                // Call getTasksInfo function to get task information
                const tasks = yield getTasksInfo(oboCredential);
                return { taskResult: tasks };
            }
            // If graphType is "task" and method is "POST"
            case "task:POST": {
                // Call createTask function to create a new task
                const tasks = yield createTask(oboCredential, reqData);
                return { taskResult: tasks };
            }
            // If graphType is "files" and method is "GET"
            case "files:GET": {
                // Call getFiles function to get files
                const files = yield getFiles(oboCredential);
                return { filesResult: files };
            }
            // If no matching graphType and method combination is found
            default: {
                throw new Error(`Invalid graphType (${graphType}) or method (${method})`);
            }
        }
    });
}
/**
 * Retrieves the user's calendar events for the current day.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns A promise that resolves with an array of calendar events.
 */
function getCalendarEvents(oboCredential) {
    return __awaiter(this, void 0, void 0, function* () {
        const graphClient = (0, teamsfx_1.createMicrosoftGraphClientWithCredential)(oboCredential, ["Calendars.Read"]);
        // Set the end of the day to 23:59:59.999
        const endOfDay = new Date();
        endOfDay.setUTCHours(23, 59, 59, 999);
        // Get the user's calendar events for the current day
        const { value: calendarValue } = yield graphClient
            .api(`/me/events?$top=2&$select=subject,bodyPreview,organizer,attendees,start,end,location,onlineMeeting&$filter=start/dateTime ge '${new Date().toUTCString()}' and start/dateTime lt '${endOfDay.toUTCString()}'`)
            .get();
        // Map the calendar events to a simpler format
        const calendarItems = calendarValue
            .map(({ start, end, subject, location, onlineMeeting }) => ({
            startTime: start,
            endTime: end,
            title: subject,
            location: location.displayName,
            url: onlineMeeting === null || onlineMeeting === void 0 ? void 0 : onlineMeeting.joinUrl,
        }))
            .reverse();
        return calendarItems;
    });
}
/**
 * Retrieves the tasks that are not completed from the user's to-do list.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns {Promise<TaskModel[]>} - A promise that resolves with an array of tasks.
 */
function getTasksInfo(oboCredential) {
    return __awaiter(this, void 0, void 0, function* () {
        // Create a Microsoft Graph client with the provided credential and required permissions
        const graphClient = (0, teamsfx_1.createMicrosoftGraphClientWithCredential)(oboCredential, ["Tasks.ReadWrite"]);
        // Get the user's to-do lists
        const { value: tasklists } = yield graphClient.api("/me/todo/lists").get();
        // Get the ID of the first to-do list
        const { id: todoTaskListId } = tasklists[0];
        // Get the tasks from the to-do list that are not completed and limit the results to 3
        const { value: tasksInfo } = yield graphClient
            .api(`/me/todo/lists/${todoTaskListId}/tasks?$filter=status ne 'completed'&$top=3`)
            .get();
        // Map the tasks to a simpler format
        const tasks = tasksInfo.map(({ id, title, status, importance, content }) => ({
            id,
            name: title,
            status,
            importance,
            content,
        }));
        return tasks;
    });
}
/**
 * Creates a new task in the user's to-do list and retrieves the tasks that are not completed.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @param {any} reqData - The request data containing the task title.
 * @returns A promise that resolves with an array of tasks.
 */
function createTask(oboCredential, reqData) {
    return __awaiter(this, void 0, void 0, function* () {
        const graphClient = (0, teamsfx_1.createMicrosoftGraphClientWithCredential)(oboCredential, [
            "Tasks.ReadWrite",
            "User.Read",
        ]);
        // Get the user's to-do lists
        const { value: tasklists } = yield graphClient.api("/me/todo/lists").get();
        // Get the ID of the first to-do list
        const { id: todoTaskListId } = tasklists[0];
        // Create a new task in the user's to-do list with the provided title
        yield graphClient
            .api(`/me/todo/lists/${todoTaskListId}/tasks`)
            .post({ title: reqData.taskTitle });
        // Import the TeamsFx SDK and create a new instance for the app identity
        let teamsfxApp = new teamsfx_1.TeamsFx(teamsfx_1.IdentityType.App);
        // Send an activity notification to the user's Teams activity feed
        sendActivityNotification(teamsfxApp, graphClient);
        // Get the tasks from the to-do list that are not completed and limit the results to 3
        const { value: tasksInfo } = yield graphClient
            .api(`/me/todo/lists/${todoTaskListId}/tasks?$filter=status ne 'completed'&$top=3`)
            .get();
        // Map the tasks to a simpler format
        const tasks = tasksInfo.map(({ id, title, status, importance, content }) => ({
            id,
            name: title,
            status,
            importance,
            content,
        }));
        return tasks;
    });
}
/**
 * Sends an activity notification to the user's Teams activity feed.
 *
 * @param {TeamsFx} teamsfxApp - The TeamsFx instance for the app identity.
 * @param {Client} graphClient - The Microsoft Graph client.
 */
function sendActivityNotification(teamsfxApp, graphClient) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // Create a Microsoft Graph client using the app identity and the default scope
            const appGraphClient = (0, teamsfx_1.createMicrosoftGraphClient)(teamsfxApp, [".default"]);
            // Get user ID
            const userProfile = yield graphClient.api("/me").get();
            const userId = userProfile["id"];
            // Construct the API path to retrieve the app installation information
            const apiPath = `/users/${userId}/teamwork/installedApps?$expand=teamsApp,teamsAppDefinition&$filter=teamsApp/externalId eq '${config_1.default.teamsAppId}'`;
            const appInstallationInfo = yield appGraphClient.api(apiPath).get();
            // Extract the installation ID from the app installation info
            const appArray = appInstallationInfo["value"][0];
            const installationId = appArray["id"];
            // Create the post body for the activity notification
            let postbody = {
                topic: {
                    source: "entityUrl",
                    value: `https://graph.microsoft.com/v1.0/users/${userId}/teamwork/installedApps/${installationId}`,
                },
                activityType: "taskCreated",
                previewText: {
                    content: "Task Created",
                },
            };
            // Send the activity notification to the user's Teams activity feed
            yield appGraphClient
                .api("users/" + userId + "/teamwork/sendActivityNotification")
                .post(postbody);
        }
        catch (error) {
            console.error("sendActivityNotification error: ", error);
        }
    });
}
/**
 * Retrieves the user's recently accessed files.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns A promise that resolves with an array of files.
 */
function getFiles(oboCredential) {
    return __awaiter(this, void 0, void 0, function* () {
        const graphClient = (0, teamsfx_1.createMicrosoftGraphClientWithCredential)(oboCredential, ["Calendars.Read"]);
        // Get the user's recently accessed files
        const { value: driveInfo } = yield graphClient
            .api("/me/drive/recent?$top=5&$select=id,name,webUrl,createdBy,lastModifiedBy,remoteItem")
            .get();
        // Map the files to a simpler format
        const returnAnswer = driveInfo.map(({ id, name, remoteItem: { createdBy, lastModifiedBy, createdDateTime, lastModifiedDateTime, file: { mimeType }, webDavUrl, sharepointIds, }, webUrl, }) => ({
            id,
            name,
            createdBy: createdBy.user.displayName,
            lastModifiedBy: lastModifiedBy.user.displayName,
            createdDateTime,
            lastModifiedDateTime,
            type: mimeType,
            weburl: webUrl,
            webDavurl: webDavUrl,
            teamsurl: generateTeamsUrl({
                webUrl,
                mimeType,
                webDavUrl,
                sharepointIds: sharepointIds.siteUrl,
            }),
        }));
        return returnAnswer;
    });
}
/**
 * Generates a Teams URL for a file.
 *
 * @param {Object} param0 - The file information.
 * @returns {string} - The Teams URL.
 */
function generateTeamsUrl({ webUrl, mimeType, webDavUrl, sharepointIds }) {
    let url = "https://teams.microsoft.com/l/file/";
    // Get the file ID from the web URL
    const fileIdStartIndex = webUrl.indexOf("sourcedoc=%7B") + 13;
    const fileIdEndIndex = webUrl.indexOf("%7D");
    const fileId = webUrl.substring(fileIdStartIndex, fileIdEndIndex);
    url += fileId + "?";
    // Get the file type from the MIME type
    let fileTypeString = "";
    switch (mimeType) {
        case FilesType.WORD:
            fileTypeString = "docx";
            break;
        case FilesType.EXCEL:
            fileTypeString = "xlsx";
            break;
        case FilesType.PPT:
            fileTypeString = "pptx";
            break;
        case FilesType.VISIO:
            fileTypeString = "vsd";
            break;
        default:
            fileTypeString = mimeType.substring(mimeType.indexOf("application/" + 12));
            break;
    }
    url += "fileType=" + fileTypeString;
    // Encode the object URL and add it to the URL
    const encodedObjectURL = webDavUrl.replace(/:/g, "%3A").replace(/\//g, "%2F");
    url += "&objectUrl=" + encodedObjectURL;
    // Encode the base URL and add it to the URL
    const encodedBaseUrl = sharepointIds.replace(/:/g, "%3A").replace(/\//g, "%2F");
    url += "&baseUrl=" + encodedBaseUrl;
    return url;
}
//# sourceMappingURL=index.js.map