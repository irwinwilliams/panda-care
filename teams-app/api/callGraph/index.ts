/* This code sample provides a starter kit to implement server side logic for your Teams App in TypeScript,
 * refer to https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference for complete Azure Functions
 * developer guide.
 */

// Import polyfills for fetch required by msgraph-sdk-javascript.
import "isomorphic-fetch";

import { Context, HttpRequest } from "@azure/functions";
import { Client } from "@microsoft/microsoft-graph-client";
import {
  createMicrosoftGraphClient,
  createMicrosoftGraphClientWithCredential,
  IdentityType,
  OnBehalfOfCredentialAuthConfig,
  OnBehalfOfUserCredential,
  TeamsFx,
} from "@microsoft/teamsfx";

import config from "../config";

// Define a Response interface with a status number and a body object that can contain any key-value pairs.
interface Response {
  status: number;
  body: { [key: string]: any };
}

// Define a TeamsfxContext type as an object that can contain any key-value pairs.
type TeamsfxContext = { [key: string]: any };

// Define an enum called FilesType with four possible values for different types of Microsoft Office files.
enum FilesType {
  WORD = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  EXCEL = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  PPT = "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  VISIO = "application/vnd.ms-visio.drawing",
}

/**
 * This function handles requests from teamsfx client.
 * The HTTP request should contain an SSO token queried from Teams in the header.
 * Before trigger this function, teamsfx binding would process the SSO token and generate teamsfx configuration.
 *
 * This function initializes the teamsfx SDK with the configuration and calls these APIs:
 * - new OnBehalfOfUserCredential(accessToken, oboAuthConfig) - Construct OnBehalfOfUserCredential instance with the received SSO token and initialized configuration.
 * - getUserInfo() - Get the user's information from the received SSO token.
 * - createMicrosoftGraphClientWithCredential() - Get a graph client to access user's Microsoft 365 data.
 *
 * The response contains multiple message blocks constructed into a JSON object, including:
 * - An echo of the request body.
 * - The display name encoded in the SSO token.
 * - Current user's Microsoft 365 profile if the user has consented.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 */

/**
 * This function is the entry point for the Azure Function.
 * It handles HTTP requests from the Teams client and calls the appropriate function based on the request parameters.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 * @returns {Promise<Response>} - A promise that resolves with the HTTP response.
 */
export default async function run(
  context: Context,
  req: HttpRequest,
  teamsfxContext: TeamsfxContext
): Promise<Response> {
  context.log("HTTP trigger function processed a request.");

  // Initialize response.
  const res: Response = {
    status: 200,
    body: {},
  };

  // Put an echo into response body.
  res.body.receivedHTTPRequestBody = req.body || "";

  // Prepare access token.
  const accessToken: string = teamsfxContext["AccessToken"];
  if (!accessToken) {
    return {
      status: 400,
      body: {
        error: "No access token was found in request header.",
      },
    };
  }

  // Set up the configuration for the OnBehalfOfUserCredential.
  const oboAuthConfig: OnBehalfOfCredentialAuthConfig = {
    authorityHost: config.authorityHost,
    clientId: config.clientId,
    tenantId: config.tenantId,
    clientSecret: config.clientSecret,
  };

  let oboCredential: OnBehalfOfUserCredential;
  try {
    // Construct the OnBehalfOfUserCredential using the access token and configuration.
    oboCredential = new OnBehalfOfUserCredential(accessToken, oboAuthConfig);
  } catch (e) {
    context.log.error(e);
    return {
      status: 500,
      body: {
        error:
          "Failed to construct OnBehalfOfUserCredential using your accessToken. " +
          "Ensure your function app is configured with the right Azure AD App registration.",
      },
    };
  }

  // Get the graphType, method, and request data from the HTTP request.
  const graphType = req.query["graphType"];
  const method = req.method;
  const reqData = req.body;

  try {
    // Call the appropriate function based on the graphType and method.
    const result = await handleRequest(oboCredential, graphType, method, reqData);
    res.body = { ...res.body, ...result };
  } catch (e) {
    context.log.error(e);
    return {
      status: 500,
      body: {
        error: "Failed to process request.",
      },
    };
  }

  return res;
}

/**
 * Handles the request based on the given graphType and method.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @param {string} graphType - The type of graph to query (e.g. "calendar", "task").
 * @param {string} method - The HTTP method to use (e.g. "GET", "POST").
 * @param {any} reqData - The request data to use (if applicable).
 * @returns {Promise<any>} - A promise that resolves with the result of the request.
 */
async function handleRequest(
  oboCredential: OnBehalfOfUserCredential,
  graphType: string,
  method: string,
  reqData: any
): Promise<any> {
  // Switch statement to handle different graphType and method combinations
  switch (`${graphType}:${method}`) {
    // If graphType is "calendar" and method is "GET"
    case "calendar:GET": {
      // Call getCalendarEvents function to get calendar events
      const events = await getCalendarEvents(oboCredential);
      return { eventResult: events };
    }
    // If graphType is "task" and method is "GET"
    case "task:GET": {
      // Call getTasksInfo function to get task information
      const tasks = await getTasksInfo(oboCredential);
      return { taskResult: tasks };
    }
    // If graphType is "task" and method is "POST"
    case "task:POST": {
      // Call createTask function to create a new task
      const tasks = await createTask(oboCredential, reqData);
      return { taskResult: tasks };
    }
    // If graphType is "files" and method is "GET"
    case "files:GET": {
      // Call getFiles function to get files
      const files = await getFiles(oboCredential);
      return { filesResult: files };
    }
    // If no matching graphType and method combination is found
    default: {
      throw new Error(`Invalid graphType (${graphType}) or method (${method})`);
    }
  }
}

/**
 * Retrieves the user's calendar events for the current day.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns A promise that resolves with an array of calendar events.
 */
async function getCalendarEvents(oboCredential: OnBehalfOfUserCredential) {
  const graphClient = createMicrosoftGraphClientWithCredential(oboCredential, ["Calendars.Read"]);

  // Set the end of the day to 23:59:59.999
  const endOfDay = new Date();
  endOfDay.setUTCHours(23, 59, 59, 999);

  // Get the user's calendar events for the current day
  const { value: calendarValue } = await graphClient
    .api(
      `/me/events?$top=2&$select=subject,bodyPreview,organizer,attendees,start,end,location,onlineMeeting&$filter=start/dateTime ge '${new Date().toUTCString()}' and start/dateTime lt '${endOfDay.toUTCString()}'`
    )
    .get();

  // Map the calendar events to a simpler format
  const calendarItems = calendarValue
    .map(({ start, end, subject, location, onlineMeeting }) => ({
      startTime: start,
      endTime: end,
      title: subject,
      location: location.displayName,
      url: onlineMeeting?.joinUrl,
    }))
    .reverse();

  return calendarItems;
}

/**
 * Retrieves the tasks that are not completed from the user's to-do list.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns {Promise<TaskModel[]>} - A promise that resolves with an array of tasks.
 */
async function getTasksInfo(oboCredential: OnBehalfOfUserCredential) {
  // Create a Microsoft Graph client with the provided credential and required permissions
  const graphClient = createMicrosoftGraphClientWithCredential(oboCredential, ["Tasks.ReadWrite"]);

  // Get the user's to-do lists
  const { value: tasklists } = await graphClient.api("/me/todo/lists").get();

  // Get the ID of the first to-do list
  const { id: todoTaskListId } = tasklists[0];

  // Get the tasks from the to-do list that are not completed and limit the results to 3
  const { value: tasksInfo } = await graphClient
    .api(`/me/todo/lists/${todoTaskListId}/tasks?$filter=status ne 'completed'&$top=3`)
    .get();

  // Map the tasks to a simpler format
  const tasks = tasksInfo.map(({ id, title, status, importance, content }) => ({
    id,
    name: title,
    status,
    importance,
    content,
  }));

  return tasks;
}

/**
 * Creates a new task in the user's to-do list and retrieves the tasks that are not completed.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @param {any} reqData - The request data containing the task title.
 * @returns A promise that resolves with an array of tasks.
 */
async function createTask(oboCredential: OnBehalfOfUserCredential, reqData: any) {
  const graphClient = createMicrosoftGraphClientWithCredential(oboCredential, [
    "Tasks.ReadWrite",
    "User.Read",
  ]);

  // Get the user's to-do lists
  const { value: tasklists } = await graphClient.api("/me/todo/lists").get();

  // Get the ID of the first to-do list
  const { id: todoTaskListId } = tasklists[0];

  // Create a new task in the user's to-do list with the provided title
  await graphClient
    .api(`/me/todo/lists/${todoTaskListId}/tasks`)
    .post({ title: reqData.taskTitle });

  // Import the TeamsFx SDK and create a new instance for the app identity
  let teamsfxApp = new TeamsFx(IdentityType.App);

  // Send an activity notification to the user's Teams activity feed
  sendActivityNotification(teamsfxApp, graphClient);

  // Get the tasks from the to-do list that are not completed and limit the results to 3
  const { value: tasksInfo } = await graphClient
    .api(`/me/todo/lists/${todoTaskListId}/tasks?$filter=status ne 'completed'&$top=3`)
    .get();

  // Map the tasks to a simpler format
  const tasks = tasksInfo.map(({ id, title, status, importance, content }) => ({
    id,
    name: title,
    status,
    importance,
    content,
  }));

  return tasks;
}

/**
 * Sends an activity notification to the user's Teams activity feed.
 *
 * @param {TeamsFx} teamsfxApp - The TeamsFx instance for the app identity.
 * @param {Client} graphClient - The Microsoft Graph client.
 */
async function sendActivityNotification(teamsfxApp: TeamsFx, graphClient: Client) {
  try {
    // Create a Microsoft Graph client using the app identity and the default scope
    const appGraphClient = createMicrosoftGraphClient(teamsfxApp, [".default"]);

    // Get user ID
    const userProfile = await graphClient.api("/me").get();
    const userId = userProfile["id"];

    // Construct the API path to retrieve the app installation information
    const apiPath = `/users/${userId}/teamwork/installedApps?$expand=teamsApp,teamsAppDefinition&$filter=teamsApp/externalId eq '${config.teamsAppId}'`;
    const appInstallationInfo = await appGraphClient.api(apiPath).get();

    // Extract the installation ID from the app installation info
    const appArray = appInstallationInfo["value"][0];
    const installationId = appArray["id"];

    // Create the post body for the activity notification
    let postbody = {
      topic: {
        source: "entityUrl",
        value: `https://graph.microsoft.com/v1.0/users/${userId}/teamwork/installedApps/${installationId}`,
      },
      activityType: "taskCreated",
      previewText: {
        content: "Task Created",
      },
    };

    // Send the activity notification to the user's Teams activity feed
    await appGraphClient
      .api("users/" + userId + "/teamwork/sendActivityNotification")
      .post(postbody);
  } catch (error) {
    console.error("sendActivityNotification error: ", error);
  }
}

/**
 * Retrieves the user's recently accessed files.
 *
 * @param {OnBehalfOfUserCredential} oboCredential - The on-behalf-of user credential.
 * @returns A promise that resolves with an array of files.
 */
async function getFiles(oboCredential: OnBehalfOfUserCredential) {
  const graphClient = createMicrosoftGraphClientWithCredential(oboCredential, ["Calendars.Read"]);

  // Get the user's recently accessed files
  const { value: driveInfo } = await graphClient
    .api("/me/drive/recent?$top=5&$select=id,name,webUrl,createdBy,lastModifiedBy,remoteItem")
    .get();

  // Map the files to a simpler format
  const returnAnswer = driveInfo.map(
    ({
      id,
      name,
      remoteItem: {
        createdBy,
        lastModifiedBy,
        createdDateTime,
        lastModifiedDateTime,
        file: { mimeType },
        webDavUrl,
        sharepointIds,
      },
      webUrl,
    }) => ({
      id,
      name,
      createdBy: createdBy.user.displayName,
      lastModifiedBy: lastModifiedBy.user.displayName,
      createdDateTime,
      lastModifiedDateTime,
      type: mimeType,
      weburl: webUrl,
      webDavurl: webDavUrl,
      teamsurl: generateTeamsUrl({
        webUrl,
        mimeType,
        webDavUrl,
        sharepointIds: sharepointIds.siteUrl,
      }),
    })
  );

  return returnAnswer;
}

/**
 * Generates a Teams URL for a file.
 *
 * @param {Object} param0 - The file information.
 * @returns {string} - The Teams URL.
 */
function generateTeamsUrl({ webUrl, mimeType, webDavUrl, sharepointIds }): string {
  let url = "https://teams.microsoft.com/l/file/";

  // Get the file ID from the web URL
  const fileIdStartIndex = webUrl.indexOf("sourcedoc=%7B") + 13;
  const fileIdEndIndex = webUrl.indexOf("%7D");
  const fileId = webUrl.substring(fileIdStartIndex, fileIdEndIndex);
  url += fileId + "?";

  // Get the file type from the MIME type
  let fileTypeString = "";
  switch (mimeType) {
    case FilesType.WORD:
      fileTypeString = "docx";
      break;
    case FilesType.EXCEL:
      fileTypeString = "xlsx";
      break;
    case FilesType.PPT:
      fileTypeString = "pptx";
      break;
    case FilesType.VISIO:
      fileTypeString = "vsd";
      break;
    default:
      fileTypeString = mimeType.substring(mimeType.indexOf("application/" + 12));
      break;
  }
  url += "fileType=" + fileTypeString;

  // Encode the object URL and add it to the URL
  const encodedObjectURL = webDavUrl.replace(/:/g, "%3A").replace(/\//g, "%2F");
  url += "&objectUrl=" + encodedObjectURL;

  // Encode the base URL and add it to the URL
  const encodedBaseUrl = sharepointIds.replace(/:/g, "%3A").replace(/\//g, "%2F");
  url += "&baseUrl=" + encodedBaseUrl;

  return url;
}
